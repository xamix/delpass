{"version":3,"file":"js/alwan.min.js","mappings":"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","sources":["webpack://Alwan/webpack/universalModuleDefinition","webpack://Alwan/webpack/bootstrap","webpack://Alwan/webpack/runtime/define property getters","webpack://Alwan/webpack/runtime/hasOwnProperty shorthand","webpack://Alwan/./src/constants/classnames.js","webpack://Alwan/./src/constants/globals.js","webpack://Alwan/./src/utils/string.js","webpack://Alwan/./src/core/events/binder.js","webpack://Alwan/./src/utils/object.js","webpack://Alwan/./src/utils/util.js","webpack://Alwan/./src/utils/dom.js","webpack://Alwan/./src/utils/number.js","webpack://Alwan/./src/lib/popper.js","webpack://Alwan/./src/components/App.js","webpack://Alwan/./src/assets/svg.js","webpack://Alwan/./src/colors/stringify.js","webpack://Alwan/./src/colors/parser.js","webpack://Alwan/./src/core/component.js","webpack://Alwan/./src/components/Palette.js","webpack://Alwan/./src/components/Utility.js","webpack://Alwan/./src/components/Sliders.js","webpack://Alwan/./src/components/Inputs.js","webpack://Alwan/./src/components/Swatches.js","webpack://Alwan/./src/core/color.js","webpack://Alwan/./src/constants/defaults.js","webpack://Alwan/./src/index.js","webpack://Alwan/./src/core/events/dispatcher.js","webpack://Alwan/./src/components/reference.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Alwan\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Alwan\"] = factory();\n\telse\n\t\troot[\"Alwan\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ALWAN_CLASSNAME = 'alwan';\r\nexport const CONTAINER_CLASSNAME = `${ALWAN_CLASSNAME}__container`;\r\nexport const PALETTE_CLASSNAME = `${ALWAN_CLASSNAME}__palette`;\r\nexport const MARKER_CLASSNAME = `${ALWAN_CLASSNAME}__marker`;\r\nexport const PREVIEW_CLASSNAME = `${ALWAN_CLASSNAME}__preview`;\r\nexport const BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__button`;\r\nexport const COPY_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__copy-button`;\r\nexport const SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider`;\r\nexport const SLIDERS_CLASSNAME = `${ALWAN_CLASSNAME}__sliders`;\r\nexport const HUE_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--hue`;\r\nexport const ALPHA_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--alpha`;\r\nexport const INPUT_CLASSNAME = `${ALWAN_CLASSNAME}__input`;\r\nexport const INPUTS_CLASSNAME = `${ALWAN_CLASSNAME}__inputs`;\r\nexport const SWATCH_CLASSNAME = `${ALWAN_CLASSNAME}__swatch`;\r\nexport const SWATCHES_CLASSNAME = `${ALWAN_CLASSNAME}__swatches`;\r\nexport const PRESET_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__preset-button`;\r\nexport const OVERLAY_CLASSNAME = `${ALWAN_CLASSNAME}__overlay`;\r\nexport const COLLAPSE_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__collapse-button`;\r\n\r\nexport const POPUP_CLASSNAME = `${ALWAN_CLASSNAME}--popup`;\r\nexport const OPEN_CLASSNAME = `${ALWAN_CLASSNAME}--open`;\r\nexport const COLLAPSE_CLASSNAME = `${ALWAN_CLASSNAME}--collapse`;","export const ROOT = document;\r\nexport const HTML = ROOT.documentElement;\r\n\r\nexport const BUTTON = 'button';\r\n\r\nexport const OPEN = 'open';\r\nexport const CLOSE = 'close';\r\nexport const COLOR = 'color';\r\nexport const CLICK = 'click';\r\nexport const POINTER_DOWN = 'pointerdown';\r\nexport const POINTER_MOVE = 'pointermove';\r\nexport const POINTER_UP = 'pointerup';\r\nexport const SCROLL = 'scroll';\r\nexport const RESIZE = 'resize';\r\nexport const KEY_DOWN = 'keydown';\r\nexport const INPUT = 'input';\r\nexport const CHANGE = 'change';\r\nexport const FOCUS_OUT = 'focusout';\r\nexport const FOCUS_IN = 'focusin';\r\nexport const MOUSE_OUT = 'mouseout';\r\n\r\nexport const HEX_FORMAT = 'hex';\r\nexport const RGB_FORMAT = 'rgb';\r\nexport const HSL_FORMAT = 'hsl';\r\n\r\nexport const TAB = 'Tab';\r\nexport const ENTER = 'Enter';\r\nexport const ESCAPE = 'Escape';\r\n\r\nexport const COLOR_PROPERTY = '--lw-' + COLOR;\r\n\r\n// Picker supported color formats.\r\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\r\nexport const INSERT_BEFORE_FIRST_CHILD = 'afterbegin';","/**\r\n * Checks if a value is a string.\r\n *\r\n * @param {unknown} value - Value to check.\r\n * @returns {boolean} Whether value is a string.\r\n */\r\nexport const isString = (value) => {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Trims a string.\r\n *\r\n * @param {string} str - String to trim.\r\n * @returns {string} trimmed string\r\n */\r\nexport const trimString = (str) => {\r\n    return str.trim();\r\n}","import { isString } from \"../../utils/string\";\r\n\r\n/**\r\n * Adds event listeners to an element and stores its data.\r\n *\r\n * @returns {object}\r\n */\r\nexport const Binder = () => {\r\n    /**\r\n     * Stores event listeners data.\r\n     */\r\n    let eventListenersData = [];\r\n\r\n    /**\r\n     * Adds/Removes event listeners.\r\n     *\r\n     * @param {EventTarget} eventTarget - Event target.\r\n     * @param {array<string>} events - Events (event type)\r\n     * @param {Function} handler - Event handler.\r\n     * @param {boolean} toggler - add/remove event listener.\r\n     */\r\n    let toggleEventListener = (eventTarget, events, handler, toggler = true) => {\r\n        events.forEach(event => {\r\n            eventTarget[`${toggler?`add`:`remove`}EventListener`](event, handler);\r\n        });\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * binds an event listener to an element.\r\n         *\r\n         * @param {EventTarget} eventTarget - Event target.\r\n         * @param {string|Array<string>} events - Event(s)\r\n         * @param {Function} handler - Event handler.\r\n         */\r\n        _bind(eventTarget, events, handler) {\r\n            if (isString(events)) {\r\n                events = [events];\r\n            }\r\n            eventListenersData.push([eventTarget, events, handler]);\r\n            toggleEventListener(eventTarget, events, handler);\r\n        },\r\n\r\n        /**\r\n         * Removes all event listeners and clears their data.\r\n         */\r\n        _unbindAll() {\r\n            eventListenersData.forEach(([target, events, handler]) => {\r\n                toggleEventListener(target, events, handler, false);\r\n            });\r\n            eventListenersData = [];\r\n        }\r\n    }\r\n}","export const { keys, assign: merge, setPrototypeOf, prototype } = Object;\r\n\r\n/**\r\n * Iterate in an object.\r\n * If any callback function return a value different then null or undefined,\r\n * then stop iteration and return that value.\r\n *\r\n * @param {Object} object - Any object.\r\n * @param {Function} fn - A Callback function.\r\n * @returns {any}\r\n */\r\nexport const objectIterator = (object, fn) => {\r\n    let props = keys(object);\r\n    for (const prop of props) {\r\n       fn(object[prop], prop);\r\n    }\r\n}","/**\r\n * Checks if a value is not undefined or null.\r\n *\r\n * @param {Any} value - Value.\r\n * @returns {Boolean}\r\n */\r\nexport const isset = value => value != null;","import { BUTTON_CLASSNAME, SLIDER_CLASSNAME } from \"../constants/classnames\";\r\nimport { BUTTON, HTML, INPUT, ROOT } from \"../constants/globals\";\r\nimport { merge, objectIterator } from \"./object\";\r\nimport { isString, trimString } from \"./string\";\r\nimport { isset } from \"./util\";\r\n\r\n/**\r\n * Gets the body element.\r\n *\r\n * @returns Document's body.\r\n */\r\nexport const body = () => ROOT.body;\r\n\r\n/**\r\n * Gets elements.\r\n *\r\n * @param {string|Element} reference - CSS selector or a HTML element.\r\n * @param {Document|Element} context - Element to search from.\r\n * @param {boolean} all - Select all elements.\r\n * @returns {null|Element|NodeList}\r\n */\r\nexport const getElement = (reference, context = ROOT, all = false) => {\r\n    if (isString(reference) && trimString(reference)) {\r\n        return context[`querySelector${ all ? 'All' : ''}`](reference);\r\n    }\r\n\r\n    if (reference instanceof Element) {\r\n        return reference;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Inserts an element relative to another element (target element).\r\n *\r\n * @param {Element} element - The element to be inserted.\r\n * @param {Element} targetElement - Element used as a reference.\r\n * @param {string} where - Insert position relative to the targetElement.\r\n * @returns {Element|undefined} - The inserted element.\r\n */\r\nexport const insertElement = (element, targetElement, where) => {\r\n    if (element && targetElement) {\r\n        return targetElement.insertAdjacentElement(where || 'beforeend', element);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets element's inner html.\r\n *\r\n * @param {Element} element - An HTML element.\r\n * @param {string} html - HTML string.\r\n */\r\nexport const setHTML = (element, html) => {\r\n    element.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Creates a new HTML Element.\r\n *\r\n * @param {string} tagName - Element tag name.\r\n * @param {string} className - Element class name.\r\n * @param {Element} targetElement - Insert the new element relative to this element using position.\r\n * @param {object} details - Element details (attributes + Initial content).\r\n * @param {InsertPosition} insertPosition - Insert position.\r\n * @returns {Element} The new created element.\r\n */\r\nexport const createElement = (tagName, className, targetElement, details, insertPosition) => {\r\n    const element = ROOT.createElement(tagName || 'div');\r\n\r\n    if (className) {\r\n        element.className = className;\r\n    }\r\n\r\n    objectIterator(details || {}, (value, name) => {\r\n        if (name === 'html') {\r\n            setHTML(element, value);\r\n        } else if (value) {\r\n            element.setAttribute(name, value);\r\n        }\r\n    });\r\n\r\n    if (targetElement) {\r\n        insertElement(element, targetElement, insertPosition);\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * Gets element's bounding rect.\r\n *\r\n * @param {Document|Element} element - Element.\r\n * @returns {DOMRect}\r\n */\r\nexport const getBounds = (element) => {\r\n    if (element === ROOT) {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n            top: 0,\r\n            left: 0,\r\n            right: HTML.clientWidth,\r\n            bottom: HTML.clientHeight\r\n        }\r\n    }\r\n    return element.getBoundingClientRect();\r\n}\r\n\r\n/**\r\n * Gets an element parent.\r\n *\r\n * @param {Element} element - Element.\r\n * @returns {Element|null} - The parent element.\r\n */\r\nexport const parent = (element) => {\r\n    return element.parentElement;\r\n}\r\n\r\n/**\r\n * Replaces an element in the DOM with another element.\r\n *\r\n * @param {Element} newElement - Element to replace another element.\r\n * @param {Element} oldElement - Element to be replaced by the newElement.\r\n * @returns {Element} The new element.\r\n */\r\nexport const replaceElement = (newElement, oldElement) => {\r\n    parent(oldElement).replaceChild(newElement, oldElement);\r\n    return newElement;\r\n}\r\n\r\n/**\r\n * Remove element from the document.\r\n *\r\n * @param {Element} element - Element to remove.\r\n */\r\nexport const removeElement = (element) => {\r\n    if (element) {\r\n        element.remove();\r\n    }\r\n}\r\n\r\n/**\r\n * Gets scrollable ancestor of an element (body element is not included).\r\n *\r\n * @param {Element} element - Element.\r\n * @param {array<Element|Document>} scrollables - Array of scrollable Elements.\r\n * @returns {array<Element|Document>}\r\n */\r\nexport const getScrollableAncestors = (element, scrollables = [ROOT]) => {\r\n    element = parent(element);\r\n    if (! element || element === ROOT.body) {\r\n        return scrollables;\r\n    }\r\n\r\n    if (/auto|scroll/.test(getComputedStyle(element).overflow)) {\r\n        scrollables.push(element);\r\n    }\r\n\r\n    return getScrollableAncestors(element, scrollables);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Check if an element is visible in the viewport of all scrollable elements.\r\n *\r\n * @param {Element} element - Element.\r\n * @param {Array} scrollables - Scrollable elements.\r\n * @returns {boolean}\r\n */\r\nexport const isInViewport = (element, scrollables) => {\r\n    return scrollables.every(scrollable => {\r\n        let { x: elementX, y: elementY, bottom: elementBottom, right: elementRight } = getBounds(element);\r\n        let { x: scrollableX, y: scrollableY, bottom: scrollableBottom, right: scrollableRight } = getBounds(scrollable);\r\n\r\n        return elementY < scrollableBottom && elementBottom > scrollableY && elementX < scrollableRight && elementRight > scrollableX;\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Sets a CSS custom property.\r\n *\r\n * @param {HTMLElement} el  - Element to set its custom property.\r\n * @param {string} property - Property name.\r\n * @param {string} value    - Property value.\r\n */\r\nexport const setCustomProperty = (element, property, value) => {\r\n    if (element && isset(value)) {\r\n        element.style.setProperty(property, value);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Hides/Shows element.\r\n *\r\n * @param {Element} element - Element to show/hide.\r\n * @param {boolean} toggler - Whether to show (true) or hide the element.\r\n */\r\nexport const toggleVisibility = (element, toggler = true) => {\r\n    element.style.display = toggler ? '' : 'none';\r\n}\r\n\r\n/**\r\n * Adds/Removes a class to/from an based on a boolean variable.\r\n *\r\n * @param {Element} element - Element.\r\n * @param {string|string[]} tokens - Class name or array of classes.\r\n * @param {boolean} toggler - Whether to add (true) or remove a class.\r\n */\r\nexport const toggleClassName = (element, tokens, toggler) => {\r\n\r\n    if (isString(tokens)) {\r\n        tokens = [tokens];\r\n    }\r\n\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            element.classList.toggle(token, toggler);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a button Element.\r\n *\r\n * @param {string} className - Class.\r\n * @param {Element} targetElement - TargetElement.\r\n * @param {object} details - Button details.\r\n * @param {string} insertPosition - Button insert position.\r\n * @returns {Element} A button.\r\n */\r\nexport const createButton = (className, targetElement, details, insertPosition) => {\r\n    return createElement(BUTTON, BUTTON_CLASSNAME + ' ' + className, targetElement, merge({ type: BUTTON }, details), insertPosition);\r\n}\r\n\r\n/**\r\n * Translates an element.\r\n *\r\n * @param {Element} element - Element to translate.\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n */\r\nexport const translate = (element, x, y) => {\r\n    element.style.transform = `translate(${x}px,${y}px)`;\r\n}\r\n\r\n/**\r\n * Creates a slider.\r\n *\r\n * @param {string} className - CSS class.\r\n * @param {Element} parent - Sldier parent.\r\n * @param {number} max - Max property.\r\n * @param {number} step - Step property.\r\n * @returns {HTMLInputElement} - Slider.\r\n */\r\nexport const createSlider = (className, parent, max, step) => {\r\n    return createElement(INPUT, SLIDER_CLASSNAME + ' ' + className, parent, { type: 'range', max, step });\r\n}","export const { parseFloat: float, parseInt: int, isFinite: isNumeric } = Number;\r\nexport const { min, max, abs, round, PI } = Math;\r\n\r\n/**\r\n * Keeps a number in a range.\r\n *\r\n * @param {number} number - A number to keep it between two numbers.\r\n * @param {number} upperBound - Max.\r\n * @param {number} lowerBound - Min.\r\n * @returns {number}\r\n */\r\nexport const boundNumber = (number, upperBound = 100, lowerBound = 0) => {\r\n    return min(max(number, lowerBound), upperBound);\r\n}\r\n\r\n/**\r\n * Angle value in degrees, it must be between 0 and 360.\r\n *\r\n * @param {number} angle - Angle.\r\n * @returns {Number}\r\n */\r\nexport const normalizeAngle = angle => {\r\n    return (round(angle) % 360 + 360) % 360;\r\n}","import { ROOT } from \"../constants/globals\";\r\nimport { getBounds, translate } from \"../utils/dom\";\r\nimport { abs, float, isNumeric, round } from \"../utils/number\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { isString } from \"../utils/string\";\r\n\r\n/**\r\n * Popper constants.\r\n */\r\nconst TOP = 'top';\r\nconst BOTTOM = 'bottom';\r\nconst RIGHT = 'right';\r\nconst LEFT = 'left';\r\nconst START = 'start';\r\nconst CENTER = 'center';\r\nconst END = 'end';\r\n\r\nconst dimension = {\r\n    x: 'width',\r\n    y: 'height'\r\n}\r\n\r\nconst upperBound = {\r\n    x: RIGHT,\r\n    y: BOTTOM\r\n}\r\n\r\nconst X_AXIS = 'x';\r\nconst Y_AXIS = 'y';\r\n\r\n/**\r\n * Creates popper instance.\r\n *\r\n * @param {Element} reference - Popper reference element.\r\n * @param {Element} container - Popper container.\r\n * @param {object} param2 - Popper options.\r\n * @returns {object} - Popper instance.\r\n */\r\nexport const createPopper = (reference, container, { _margin, _position }) => {\r\n    /**\r\n     * Sides to fallback to.\r\n     */\r\n    let fallbackSides = {\r\n        [TOP]:    [TOP, BOTTOM, RIGHT, LEFT],\r\n        [BOTTOM]: [BOTTOM, TOP, RIGHT, LEFT],\r\n        [RIGHT]:  [RIGHT, LEFT, TOP, BOTTOM],\r\n        [LEFT]:   [LEFT, RIGHT, TOP, BOTTOM]\r\n    };\r\n    /**\r\n     * Alignments to fallback to.\r\n     */\r\n    let fallbackAlignments = {\r\n        start: [START, CENTER, END],\r\n        center: [CENTER, START, END],\r\n        end: [END, CENTER, START]\r\n    };\r\n    /**\r\n     * Popup coordinates.\r\n     */\r\n    let coordinates;\r\n\r\n    /**\r\n     * Space between the reference and the container.\r\n     */\r\n    let margin = 5;\r\n\r\n    /**\r\n     * Side and alignment from the position.\r\n     */\r\n    let [side, alignment] = isString(_position) ? _position.split('-') : [];\r\n\r\n    // Validate values.\r\n    if (! fallbackSides[side]) {\r\n        side = BOTTOM;\r\n    }\r\n    if (! alignment) {\r\n        alignment = CENTER;\r\n    } else if (! fallbackAlignments[alignment]) {\r\n        alignment = START;\r\n    }\r\n    _margin = float(_margin);\r\n    if (isNumeric(_margin)) {\r\n        margin = _margin;\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Popper Reference element.\r\n         *\r\n         * @type {Element}\r\n         */\r\n        _reference: reference,\r\n\r\n        /**\r\n         * Update container's position.\r\n         */\r\n        _update() {\r\n            let domBounds = getBounds(ROOT);\r\n            let referenceBoundingRect = getBounds(reference);\r\n            let containerBoundingRect = getBounds(container);\r\n\r\n            coordinates = {\r\n                x: null,\r\n                y: null\r\n            }\r\n\r\n            /**\r\n             * Check sides.\r\n             */\r\n            fallbackSides[side].some(referenceSide => {\r\n                let axis = referenceSide === TOP || referenceSide === BOTTOM ? Y_AXIS : X_AXIS;\r\n\r\n                let domBound = domBounds[referenceSide];\r\n                let referenceBound = referenceBoundingRect[referenceSide];\r\n\r\n                // The amount of space for the container.\r\n                let containerSpace = margin + containerBoundingRect[dimension[axis]];\r\n                // If container has available space.\r\n                if (containerSpace <= abs(domBound - referenceBound)) {\r\n                    // Calculate coordinate to set this side,\r\n                    // for the top/left sides substruct the container space from the top/left bound of the reference element,\r\n                    // and for the bottom/right sides just add the margin.\r\n                    coordinates[axis] = referenceBound + (domBound ? margin : -containerSpace);\r\n                    // Reverse the axises for the alignments.\r\n                    axis = axis === X_AXIS ? Y_AXIS : X_AXIS;\r\n\r\n                    /**\r\n                     * Check alignments, only if the container is attached.\r\n                     */\r\n                    fallbackAlignments[alignment].some(alignment => {\r\n                        // container width/height depends on the axis.\r\n                        let containerDimension = containerBoundingRect[dimension[axis]];\r\n                        // Lower bound is for the top/left coordinates.\r\n                        // Upper bound is for the bottom/right coordinates.\r\n                        // top/left coordinates are always lesser(lower) than bottom/right.\r\n                        let {\r\n                            [axis]: referenceLowerBound,\r\n                            [upperBound[axis]]: referenceUpperBound,\r\n                        } = referenceBoundingRect;\r\n                        // Distance between the reference bottom/right coordinates and the DOM,\r\n                        // bottom/right coordinates or boundries.\r\n                        let upperBoundDistance = domBounds[upperBound[axis]] - referenceLowerBound;\r\n\r\n                        // Offset between the container and the reference element.\r\n                        let offset = (containerDimension + referenceBoundingRect[dimension[axis]]) / 2;\r\n\r\n                        // Check for space availability and set the coordinate.\r\n                        if (alignment === START && containerDimension <= upperBoundDistance) {\r\n                            coordinates[axis] = referenceLowerBound;\r\n                            return true;\r\n                        }\r\n                        if (alignment === CENTER && offset <= referenceUpperBound && offset <= upperBoundDistance) {\r\n                            coordinates[axis] = referenceUpperBound - offset;\r\n                            return true;\r\n                        }\r\n                        if (alignment === END && containerDimension <= referenceUpperBound) {\r\n                            coordinates[axis] = referenceUpperBound - containerDimension;\r\n                            return true;\r\n                        }\r\n                    });\r\n                    // Exit the fallback sides loop.\r\n                    return true;\r\n                }\r\n            });\r\n            // If there is no space to position the popover in all sides,\r\n            // then center the popover in the screen.\r\n            // If the popover is attached to one side but there is no space,\r\n            // for the alignment than center it horizontally/vertically depends on the side.\r\n            objectIterator(coordinates, (value, axis) => {\r\n                if (value === null) {\r\n                    coordinates[axis] = (domBounds[upperBound[axis]] - containerBoundingRect[dimension[axis]]) / 2;\r\n                } else {\r\n                    coordinates[axis] = round(value)\r\n                }\r\n            });\r\n\r\n            translate(container, coordinates.x, coordinates.y);\r\n        }\r\n    }\r\n}","import { OPEN_CLASSNAME, POPUP_CLASSNAME } from \"../constants/classnames\";\r\nimport { BUTTON, CLOSE, ESCAPE, INPUT, KEY_DOWN, OPEN, POINTER_DOWN, RESIZE, ROOT, SCROLL, TAB } from \"../constants/globals\";\r\nimport { Binder } from \"../core/events/binder\";\r\nimport { createPopper } from \"../lib/popper\";\r\nimport { getElement, getScrollableAncestors, insertElement, isInViewport, removeElement, toggleClassName, toggleVisibility } from \"../utils/dom\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { isString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n/**\r\n * Creates App componenet and initialize components.\r\n *\r\n * @param {Element} root - Picker container.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {App}\r\n */\r\nexport const App = (root, alwan, events) => {\r\n    /**\r\n     * Alwan reference element.\r\n     */\r\n    let referenceElement;\r\n\r\n    /**\r\n     * Popper event binder.\r\n     */\r\n    let popperEvents = Binder();\r\n\r\n    /**\r\n     * Popper instance.\r\n     */\r\n    let popper;\r\n\r\n    /**\r\n     * Popper reference's scrollable ancestors.\r\n     *\r\n     * @type {Array[Element]}\r\n     */\r\n    let scrollableAncestors;\r\n\r\n    /**\r\n     * Visibility state.\r\n     */\r\n    let isOpen = false;\r\n\r\n    /**\r\n     * Setup and Initialize other components.\r\n     *\r\n     * @param {object} options - Alwan options.\r\n     * @param {object} instance - Alwan instance.\r\n     */\r\n    const _setup = (options, instance = alwan) => {\r\n        alwan = instance;\r\n        let { theme, popover, target, position, margin, id, toggle, shared } = options;\r\n        let targetElement = getElement(target);\r\n\r\n        if (isString(id) && ! shared) {\r\n            root.id = id;\r\n        }\r\n\r\n        // Initialize components.\r\n        objectIterator(alwan._components, ({ _init }) => {\r\n            if (_init) {\r\n                _init(options, alwan);\r\n            }\r\n        })\r\n\r\n        referenceElement = alwan._reference._element;\r\n        target = targetElement || referenceElement;\r\n\r\n        // Set theme (dark or light).\r\n        root.dataset.theme = theme;\r\n\r\n        // Toggle option changed to false then open (show) the picker\r\n        if (! toggle && ! shared) {\r\n            _toggle(alwan, true, true);\r\n        }\r\n        // Hide reference element if both popover and toggle are false.\r\n        // and the components are not shared.\r\n        toggleVisibility(referenceElement, popover || toggle || shared);\r\n        // Toggle popup class that makes the root's position fixed.\r\n        toggleClassName(root, POPUP_CLASSNAME, popover);\r\n\r\n        popperEvents._unbindAll();\r\n        popper = null;\r\n\r\n        if (popover) {\r\n            popper = createPopper(target, root, {\r\n                _margin: margin,\r\n                _position: position\r\n            });\r\n            popper._update();\r\n            // If reference element inside a nested scrollable elements,\r\n            // get all those scrollable elements in an array.\r\n            scrollableAncestors = getScrollableAncestors(target);\r\n            // Attach scroll event to all scrollable ancestors of the reference element,\r\n            // in order to update the popper's position.\r\n            // On window resize reposition the popper.\r\n            popperEvents._bind(window, RESIZE, updatePopper);\r\n            scrollableAncestors.forEach(scrollable => {\r\n                popperEvents._bind(scrollable, SCROLL, updatePopper);\r\n            });\r\n            popperEvents._bind(ROOT, [KEY_DOWN, POINTER_DOWN], handleAccessibility);\r\n        } else {\r\n            root.style = '';\r\n            insertElement(root, target, ! targetElement && 'afterend');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates popper's position and visibility.\r\n     *\r\n     * @param {Event} e - Event.\r\n     */\r\n    const updatePopper = e => {\r\n        if (isOpen) {\r\n\r\n            popper._update();\r\n\r\n            // Close picker if popper's reference is scrolled out of view.\r\n            if (! isInViewport(popper._reference, scrollableAncestors)) {\r\n                _toggle(alwan, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles keyboard accessibility.\r\n     *\r\n     * If picker is displayed as a popover then link the focus from the reference,\r\n     * to the picker focusable elements.\r\n     *\r\n     * @param {KeyboardEvent} e - Event.\r\n     */\r\n    const handleAccessibility = e => {\r\n        if (isOpen) {\r\n            let { target, key, shiftKey } = e;\r\n            let paletteElement = alwan._components._palette._element;\r\n            let elementToFocusOn;\r\n            let lastFocusableElement;\r\n\r\n            // Close picker if:\r\n            // - Escape key is pressed.\r\n            // - A pointerdown event happened ouside the picker and not on the reference element or one of its labels,\r\n            // (only if the reference element is a labelable element).\r\n            if (key === ESCAPE || (target !== referenceElement && ! root.contains(target) && ! [...referenceElement.labels || []].some(label => label.contains(target)))) {\r\n                _toggle(alwan, false);\r\n            } else if (key === TAB) {\r\n\r\n                lastFocusableElement = [...getElement(BUTTON + ',' + INPUT, root, true)].pop();\r\n\r\n                if (target === referenceElement && ! shiftKey) {\r\n                    // Pressing Tab while focusing on the reference element sends focus,\r\n                    // to the first element (palette) inside the picker container.\r\n                    elementToFocusOn = paletteElement;\r\n                } else if ((shiftKey && target === paletteElement) || (! shiftKey && target === lastFocusableElement)) {\r\n                    // Pressing Tab while focusing on the palette with the shift key or focussing on the last,\r\n                    // focusable element without shift key sends focus to the reference element (if it's focusable).\r\n                    elementToFocusOn = referenceElement;\r\n                }\r\n                if (elementToFocusOn) {\r\n                    e.preventDefault();\r\n                    elementToFocusOn.focus();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles color picker visiblity.\r\n     *\r\n     * @param {object} instance - Alwan instance.\r\n     * @param {boolean} state - True to open, false to close.\r\n     * @param {boolean} forced - Open/Close picker even if its disabled or the toggle option is set to false.\r\n     */\r\n    const _toggle = (instance, state, forced) => {\r\n        instance = instance || alwan;\r\n        let { shared, toggle, disabled } = instance.config;\r\n\r\n        if (! disabled || forced) {\r\n\r\n            if (! isset(state)) {\r\n                // If the instance doesn't control the components.\r\n                // then close the instance that controls the components.\r\n                if (isOpen && instance !== alwan) {\r\n                    _toggle(alwan, false);\r\n                }\r\n\r\n                state = ! isOpen;\r\n            }\r\n\r\n            if (state !== isOpen && (shared || toggle || forced)) {\r\n                if (state) {\r\n                    if (instance !== alwan) {\r\n                        // Set components to point to the new instance,\r\n                        // and update options.\r\n                        _setup(instance.config, instance);\r\n                    }\r\n                    alwan._color._update({}, true);\r\n                    _reposition();\r\n                }\r\n\r\n                // Only the instance that controls the components,\r\n                // open/close the picker.\r\n                if (instance === alwan) {\r\n                    isOpen = state;\r\n                    toggleClassName(root, OPEN_CLASSNAME, state);\r\n                    alwan._events._dispatch(state ? OPEN : CLOSE, root);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the popper's position.\r\n     */\r\n    const _reposition = () => {\r\n        if (popper) {\r\n            popper._update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets current picker state (opened or closed).\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    const _isOpen = () => {\r\n        return isOpen;\r\n    }\r\n\r\n    /**\r\n     * Destroy components and remove root element from the DOM.\r\n     */\r\n    const _destroy = () => {\r\n        // Remove components events.\r\n        events._unbindAll();\r\n        // Remove popper events.\r\n        popperEvents._unbindAll();\r\n        root = removeElement(root);\r\n        alwan = {};\r\n    }\r\n\r\n    return {\r\n        _root: root,\r\n        _setup,\r\n        _reposition,\r\n        _toggle,\r\n        _isOpen,\r\n        _destroy\r\n    }\r\n}","export const clipboardSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>`;\r\nexport const checkSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path></svg>`;\r\nexport const switchInputsSVG = `<svg width=\"15\" height=\"15\" viewBox=\"0 0 20 20\" aria-role=\"none\"><path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path></svg>`;\r\nexport const caretSVG = `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M6.984 14.016l5.016-5.016 5.016 5.016h-10.031z\"></path></svg>`;","import { HEX_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { round } from \"../utils/number.js\";\r\n\r\n/**\r\n * Converts a decimal number to hexadecimal.\r\n *\r\n * @param {number} number - A decimal number.\r\n * @returns {string} - Hexadecimal.\r\n */\r\nconst toHex = number => {\r\n    return (number < 16 ? '0' : '') + number.toString(16);\r\n}\r\n\r\n/**\r\n * Converts RGB or HSL color objects to string.\r\n *\r\n * @param {object} color - HSL or RGB color object.\r\n * @param {string} format - Color format (hex, rgb or hsl).\r\n * @param {boolean} opaque - If true, output color string with no opacity.\r\n * @returns {string} rgb or hsl string.\r\n */\r\nexport const stringify = (color, format, opaque) => {\r\n    let opacity = '';\r\n    let a = color.a;\r\n    let str = format;\r\n\r\n    if (a < 1 && ! opaque) {\r\n        str += 'a';\r\n        opacity = ', ' + a;\r\n    }\r\n\r\n    if (format === RGB_FORMAT) {\r\n        return str + `(${color.r}, ${color.g}, ${color.b + opacity})`;\r\n    }\r\n\r\n    if (format === HEX_FORMAT) {\r\n        return '#' + toHex(color.r) + toHex(color.g) + toHex(color.b) + (a < 1 ? toHex(round(a * 255)) : '');\r\n    }\r\n\r\n    return str + `(${color.h}, ${color.s}%, ${color.l}%${opacity})`;\r\n}","import { HSL_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { createElement } from \"../utils/dom\";\r\nimport { float, isNumeric, normalizeAngle, boundNumber, PI, round, int } from \"../utils/number\";\r\nimport { isString, trimString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\nimport { stringify } from \"./stringify\";\r\n\r\nconst ctx = createElement('canvas').getContext('2d');\r\n\r\n/**\r\n * Regex.\r\n */\r\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?\\s*[\\s,]\\s*([+-]?\\d*\\.?\\d+)%?\\s*,?\\s*([+-]?\\d*\\.?\\d+)%?(?:\\s*[\\/,]\\s*([+-]?\\d*\\.?\\d+)(%)?)?\\s*\\)?$/;\r\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\r\n/**\r\n * Used to convert non degrees angles to degrees.\r\n */\r\nconst ANGLE_COEFFICIENT_MAP = {\r\n    deg: 1,\r\n    turn: 360,\r\n    rad: 180 / PI,\r\n    grad: 0.9\r\n}\r\n\r\n/**\r\n * Parses any value into an RGB or HSL objects.\r\n * Invalid color values default to #000.\r\n *\r\n * @param {unknown} value - A value to parse.\r\n * @param {boolean} asString - Whether to return the result as a string or object.\r\n * @returns {object|string} - Parsed color as string or object.\r\n */\r\nexport const parseColor = (value = '', asString) => {\r\n\r\n    let color;\r\n    let format;\r\n    let str = '';\r\n\r\n    /**\r\n     * Validate Non string values, convert color objects into strings.\r\n     * Invalid values default to empty string.\r\n     */\r\n    if (! isString(value)) {\r\n\r\n        format = [RGB_FORMAT, HSL_FORMAT].find(format => {\r\n            return format.split('').every(key => {\r\n                return isNumeric(float(value[key]));\r\n            });\r\n        });\r\n\r\n        if (format) {\r\n            str = stringify(value, format);\r\n        }\r\n    } else {\r\n        str = trimString(value);\r\n    }\r\n\r\n    /**\r\n     * Parse strings\r\n     */\r\n    let [input, h, angle, s, l, a, percentage] = HSL_REGEX.exec(str) || [];\r\n\r\n    // str is a hsl string.\r\n    if (input) {\r\n        /**\r\n         * Normalize values.\r\n         *\r\n         * The hue value is so often given in degrees, it can be given as a number, however\r\n         * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradians),\r\n         * If the hue has a unit other than deg, then convert it to degrees.\r\n         */\r\n        color = {\r\n            h: normalizeAngle(h * (ANGLE_COEFFICIENT_MAP[angle] ? ANGLE_COEFFICIENT_MAP[angle] : 1)),\r\n            s: round(boundNumber(s)),\r\n            l: round(boundNumber(l)),\r\n            a: isset(a) ? boundNumber(percentage ? a / 100 : a, 1) : 1\r\n        }\r\n        format = HSL_FORMAT;\r\n    } else {\r\n        format = RGB_FORMAT;\r\n\r\n        ctx.fillStyle = '#000';\r\n        ctx.fillStyle = str;\r\n        str = ctx.fillStyle;\r\n        // ColorString is either hex or rgb string,\r\n        // if it's hex convert it to rgb object,\r\n        // if it's rgb then parse it to object.\r\n        if (HEX_REGEX.test(str)) {\r\n            // Convert hex string to rgb object.\r\n            color = {\r\n                r: int(str.slice(1, 3), 16),\r\n                g: int(str.slice(3, 5), 16),\r\n                b: int(str.slice(5, 7), 16),\r\n                a: 1\r\n            }\r\n        } else {\r\n            // Parse rgb string into a rgb object.\r\n            let [r, g, b, a] = /\\((.+)\\)/.exec(str)[1].split(',').map(value => float(value));\r\n            color = { r, g, b, a };\r\n        }\r\n    }\r\n\r\n    // Round the transparency component to two numbers behind\r\n    color.a = round(color.a * 100) / 100;\r\n\r\n    return asString ? stringify(color, format) : { _format: format, _color: color }\r\n}","import { ALWAN_CLASSNAME, CONTAINER_CLASSNAME } from \"../constants/classnames\";\r\nimport { App } from \"../components/App\";\r\nimport { Inputs } from \"../components/Inputs\";\r\nimport { Palette } from \"../components/Palette\";\r\nimport { Sliders } from \"../components/Sliders\";\r\nimport { Swatches } from \"../components/Swatches\";\r\nimport { Utility } from \"../components/Utility\";\r\nimport { body, createElement } from \"../utils/dom\";\r\nimport { Binder } from \"./events/binder\";\r\n\r\n/**\r\n * Shared Components.\r\n */\r\nlet sharedComponents = null;\r\n\r\n/**\r\n * Number of instances that uses the shared components.\r\n */\r\nlet instanceCount = 0;\r\n\r\n/**\r\n * Creates components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} alwan components.\r\n */\r\nconst createComponents = (alwan) => {\r\n    const events = Binder();\r\n    const root = createElement('', ALWAN_CLASSNAME, body());\r\n\r\n    /**\r\n     * Creates a new container element.\r\n     *\r\n     * @returns {Element} - Container Element.\r\n     */\r\n    const createContainer = () => {\r\n        return createElement('', CONTAINER_CLASSNAME, root);\r\n    }\r\n\r\n    const _app = App(root, alwan, events);\r\n    const _palette = Palette(root, alwan, events);\r\n    const container = createContainer();\r\n    const _utility = Utility(container, alwan, events);\r\n    const _sliders = Sliders(container, alwan, events);\r\n    const _inputs = Inputs(createContainer(), alwan, events);\r\n    const _swatches = Swatches(root, alwan, events);\r\n\r\n    return {\r\n        _app,\r\n        _palette,\r\n        _utility,\r\n        _sliders,\r\n        _inputs,\r\n        _swatches\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if components are shared.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {boolean} - True if components are shared.\r\n */\r\nexport const isShared = (components) => {\r\n    return !!sharedComponents && components === sharedComponents;\r\n}\r\n\r\n/**\r\n * Destroys components.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {void}\r\n */\r\nexport const destroyComponents = (components) => {\r\n    if (isShared(components)) {\r\n        instanceCount--;\r\n        if (instanceCount > 0) {\r\n            return;\r\n        }\r\n        sharedComponents = null;\r\n    }\r\n\r\n    components._app._destroy();\r\n    components = {};\r\n}\r\n\r\n/**\r\n * Gets components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} components.\r\n */\r\nexport const useComponents = (alwan) => {\r\n    let { _components, config: { shared }} = alwan;\r\n\r\n    // Alwan already has components.\r\n    if (_components) {\r\n        // Nothing is changing, if components are shared and the option shared is true,\r\n        // or the components are not shared and the option shared is false\r\n        // then just return the current compoenents.\r\n        if ((isShared(_components)) === shared) {\r\n            return _components;\r\n        }\r\n\r\n        // Force close the picker before destroying its components.\r\n        _components._app._toggle(alwan, false, true);\r\n        // If something changed, either the components were shared,\r\n        // and the option shared is false which means set the components as,\r\n        // non-shared or the coponents were non-shared and we want to share them.\r\n        // in either cases we need to destroy the current components.\r\n        destroyComponents(_components);\r\n    }\r\n\r\n    if (shared) {\r\n        // Create components and set them to sharedComponents.\r\n        if (! sharedComponents) {\r\n            sharedComponents = createComponents(alwan);\r\n        }\r\n        // Increase the instances that uses this shared components.\r\n        instanceCount++;\r\n\r\n        return sharedComponents;\r\n    }\r\n\r\n    // Create components.\r\n    return createComponents(alwan);\r\n}","import { MARKER_CLASSNAME, OVERLAY_CLASSNAME, PALETTE_CLASSNAME } from \"../constants/classnames\";\r\nimport { CHANGE, COLOR, KEY_DOWN, POINTER_DOWN, POINTER_MOVE, POINTER_UP, ROOT } from \"../constants/globals\";\r\nimport { createElement, getBounds, translate, removeElement } from \"../utils/dom\"\r\nimport { boundNumber, min } from \"../utils/number\";\r\n\r\n/**\r\n * Picker palette.\r\n *\r\n * @param {Element} root - Root element to append the palette elements to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object}\r\n */\r\nexport const Palette = (root, alwan, events) => {\r\n    /**\r\n     * Marker X coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerX;\r\n\r\n    /**\r\n     * Marker Y coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerY;\r\n\r\n    /**\r\n     * Palette element bounds.\r\n     *\r\n     * @type {DOMRect}\r\n     */\r\n    let paletteBounds;\r\n\r\n    /**\r\n     * A transparent element cover the whole document.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let overlayElement;\r\n\r\n    /**\r\n     * Indicates whether a pointer (mouse, pen or touch) is down.\r\n     */\r\n    let isPointerDown = false;\r\n\r\n    /**\r\n     * Palette element.\r\n     */\r\n    const palette = createElement('', PALETTE_CLASSNAME, root, { tabindex: '0' });\r\n\r\n    /**\r\n     * Palette marker.\r\n     */\r\n    const marker = createElement('', MARKER_CLASSNAME, palette);\r\n\r\n    /**\r\n     * Move marker horizontally using the keyboard arrow keys.\r\n     */\r\n    const keyboardX = {\r\n        ArrowRight: 1,\r\n        ArrowLeft: -1\r\n    };\r\n\r\n    /**\r\n     * Move marker vertically using the keyboard arrow keys\r\n     */\r\n    const keyboardY = {\r\n        ArrowDown: 1,\r\n        ArrowUp: -1\r\n    };\r\n\r\n    /**\r\n     * Moves marker and updaets the color state.\r\n     * Moves it using a pointer (mouse, touch or pen) or keyboard arrow keys.\r\n     *\r\n     * @param {Event} param0 - Pointer Event.\r\n     * @param {object} keyboard - Keyboard steps.\r\n     * @param {Function} change - Callback function, called when color changes.\r\n     */\r\n    const moveMarkerAndUpdateColor = ({ clientX, clientY }, keyboard, change) => {\r\n\r\n        let { x, y, width, height } = paletteBounds;\r\n        let v, L;\r\n\r\n        if (keyboard) {\r\n            x = markerX + keyboard.x * width / 100;\r\n            y = markerY + keyboard.y * height / 100;\r\n        } else {\r\n            x = clientX - x;\r\n            y = clientY - y;\r\n        }\r\n\r\n        x = boundNumber(x, width);\r\n        y = boundNumber(y, height);\r\n\r\n        if (x !== markerX || y !== markerY) {\r\n            markerX = x;\r\n            markerY = y;\r\n            translate(marker, markerX, markerY);\r\n\r\n            v = (1 - y / height);\r\n            L = v * (1 - x / (2 * width));\r\n\r\n            alwan._color._update({\r\n                S: L === 1 || L === 0 ? 0 : (v - L) / min(L, 1 - L),\r\n                L\r\n            });\r\n\r\n            alwan._events._dispatch(COLOR, palette);\r\n\r\n            if (change) {\r\n                change();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragStart = e => {\r\n        if (! overlayElement) {\r\n            overlayElement = createElement('', OVERLAY_CLASSNAME, root);\r\n        }\r\n        // Save color state.\r\n        alwan._color._saveState();\r\n        paletteBounds = getBounds(palette);\r\n        isPointerDown = true;\r\n        moveMarkerAndUpdateColor(e);\r\n        palette.focus();\r\n    }\r\n\r\n    /**\r\n     * Dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const drag = e => {\r\n        if (isPointerDown) {\r\n            moveMarkerAndUpdateColor(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drag end (released the marker).\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragEnd = e => {\r\n        if (isPointerDown) {\r\n            alwan._color._triggerChange(palette);\r\n            overlayElement = removeElement(overlayElement);\r\n            isPointerDown = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves marker using keyboard arrow keys and adds focus-visible to the palette.\r\n     *\r\n     * @param {KeyboardEvent} e - Event.\r\n     */\r\n    const handleKeyboard = e => {\r\n        let key = e.key;\r\n\r\n        if (keyboardX[key] || keyboardY[key]) {\r\n            e.preventDefault();\r\n\r\n            paletteBounds = getBounds(palette);\r\n\r\n            moveMarkerAndUpdateColor({}, { x: keyboardX[key] || 0, y: keyboardY[key] || 0 },\r\n                () => {\r\n                    alwan._events._dispatch(CHANGE, palette);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(palette, POINTER_DOWN, dragStart);\r\n    events._bind(ROOT, POINTER_MOVE, drag);\r\n    events._bind(ROOT, POINTER_UP, dragEnd);\r\n    events._bind(palette, KEY_DOWN, handleKeyboard);\r\n\r\n\r\n    return {\r\n        _element: palette,\r\n\r\n        /**\r\n         * Initialize component.\r\n         *\r\n         * @param {object} options - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init(_options, instance) {\r\n            alwan = instance || alwan;\r\n        },\r\n\r\n        /**\r\n         * Updates marker position from an hsv color object.\r\n         *\r\n         * @param {object} param0 - HSL color object.\r\n         */\r\n        _update({ S, L }) {\r\n            paletteBounds = getBounds(palette);\r\n            // Temporary hold the value of V in the HSV color space.\r\n            markerY = L + S * min(L, 1 - L);\r\n\r\n            markerX = (markerY ? 2 * (1 - L / markerY) : 0) * paletteBounds.width;\r\n            markerY = (1 - markerY) * paletteBounds.height;\r\n\r\n            translate(marker, markerX, markerY);\r\n        }\r\n    }\r\n}","import { checkSVG, clipboardSVG } from \"../assets/svg\";\r\nimport { COPY_BUTTON_CLASSNAME, PREVIEW_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLICK, FOCUS_OUT, HTML, INPUT, INSERT_BEFORE_FIRST_CHILD, MOUSE_OUT, ROOT } from \"../constants/globals\";\r\nimport { createButton, createElement, insertElement, removeElement, setHTML } from \"../utils/dom\";\r\n\r\n/**\r\n * Creates utility component.\r\n *\r\n * @param {Element} parent - Container.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @param {object} events - Event binder.\r\n * @returns {object} Utility component.\r\n */\r\nexport const Utility = (parent, alwan, events) => {\r\n    /**\r\n     * Preview color.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let previewElement;\r\n\r\n    /**\r\n     * Copy button.\r\n     *\r\n     * @type {HTMLButtonElement}\r\n     */\r\n    let copyButton;\r\n\r\n    /**\r\n     * Indicate whether color is copied.\r\n     */\r\n    let isCopied;\r\n\r\n    /**\r\n     * API.\r\n     */\r\n    const self = {\r\n        /**\r\n         * Initialize utility component.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ preview, copy }, instance) {\r\n            alwan = instance;\r\n            if (copy !== !! copyButton) {\r\n                if (copy) {\r\n                    copyButton = createButton(COPY_BUTTON_CLASSNAME, previewElement || parent, { html: clipboardSVG }, INSERT_BEFORE_FIRST_CHILD);\r\n                } else {\r\n                    copyButton = removeElement(copyButton);\r\n                }\r\n            }\r\n\r\n            if (preview !== !! previewElement) {\r\n                if (preview) {\r\n                    previewElement = createElement('', PREVIEW_CLASSNAME, parent, false, INSERT_BEFORE_FIRST_CHILD);\r\n                } else {\r\n                    previewElement = removeElement(previewElement);\r\n                }\r\n\r\n                insertElement(copyButton, previewElement || parent, INSERT_BEFORE_FIRST_CHILD);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copies the selected color to the clipboard.\r\n     *\r\n     * @param {MouseEvent} e - Event.\r\n     */\r\n    const copyColor = ({ target }) => {\r\n        if (target === copyButton && ! isCopied && ! alwan.config.disabled) {\r\n\r\n            let clipboard = navigator.clipboard;\r\n            let color = alwan._color._getColorByFormat(true);\r\n            let input;\r\n\r\n            if (clipboard) {\r\n                clipboard.writeText(color);\r\n            } else {\r\n                input = createElement(INPUT, '', HTML, { value: color });\r\n                input.select();\r\n                ROOT.execCommand('copy');\r\n                input = removeElement(input);\r\n            }\r\n            // change icon.\r\n            isCopied = true;\r\n            setHTML(copyButton, checkSVG);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Updates the svg icon of the button.\r\n     *\r\n     * @param {MouseEvent|FocusEvent} e - Event.\r\n     */\r\n    const updateButtonIcon = e => {\r\n        if (e.target === copyButton) {\r\n            // If the color is copied (that means the copy button has changed its icon),\r\n            // and the button has lost focus or mouse left it, then set the icon back,\r\n            // to the clipboard svg.\r\n            if (isCopied) {\r\n                isCopied = false;\r\n                setHTML(copyButton, clipboardSVG);\r\n            }\r\n            copyButton.blur();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(parent, CLICK, copyColor);\r\n    events._bind(parent, [MOUSE_OUT, FOCUS_OUT], updateButtonIcon);\r\n\r\n    return self;\r\n}","import { ALPHA_SLIDER_CLASSNAME, HUE_SLIDER_CLASSNAME, SLIDERS_CLASSNAME } from \"../constants/classnames\";\r\nimport { CHANGE, COLOR, INPUT } from \"../constants/globals\";\r\nimport { createElement, createSlider, removeElement, setCustomProperty } from \"../utils/dom\";\r\n\r\n/**\r\n * Creates sliders component.\r\n *\r\n * @param {Element} parent - Element to append sliders to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} Sliders component.\r\n */\r\nexport const Sliders = (parent, alwan, events) => {\r\n    /**\r\n     * Alpha slider.\r\n     *\r\n     * @type {HTMLInputElement}\r\n     */\r\n    let alphaSlider;\r\n\r\n    /**\r\n     * Sliders container.\r\n     */\r\n    const container = createElement('', SLIDERS_CLASSNAME, parent);\r\n\r\n    /**\r\n     * Hue slider.\r\n     *\r\n     * @type {HTMLInputElement}\r\n     */\r\n    const hueSlider = createSlider(HUE_SLIDER_CLASSNAME, container, 360);\r\n\r\n    /**\r\n     * Updates color.\r\n     *\r\n     * @param {InputEvent} param0 - Event.\r\n     */\r\n    const handleChange = ({ target, type, target: { value } }) => {\r\n        alwan._color._update(target === hueSlider ? { h: 360 - value } : { a: value * 1 });\r\n        alwan._events._dispatch(type === CHANGE ? CHANGE : COLOR, target);\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(container, [INPUT, CHANGE], handleChange);\r\n\r\n\r\n    return {\r\n        /**\r\n         * Initialize sliders.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ opacity }, instance) {\r\n            alwan = instance || alwan;\r\n\r\n            if (opacity !== !! alphaSlider) {\r\n                if (opacity) {\r\n                    alphaSlider = createSlider(ALPHA_SLIDER_CLASSNAME, container, 1, 0.01);\r\n                } else {\r\n                    alphaSlider = removeElement(alphaSlider);\r\n                    alwan._color._update({ a: 1 });\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets sliders values.\r\n         *\r\n         * @param {object} param0 - HSV color object.\r\n         */\r\n        _update({ h, a }) {\r\n            hueSlider.value = 360 - h;\r\n            if (alphaSlider) {\r\n                alphaSlider.value = a;\r\n            }\r\n        }\r\n    };\r\n}","import { switchInputsSVG } from \"../assets/svg\";\r\nimport { INPUTS_CLASSNAME, INPUT_CLASSNAME } from \"../constants/classnames\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport { CHANGE, CLICK, COLOR, COLOR_FORMATS, ENTER, FOCUS_IN, HEX_FORMAT, INPUT, KEY_DOWN, RGB_FORMAT} from \"../constants/globals\";\r\nimport { createButton, createElement, removeElement, setHTML, toggleVisibility } from \"../utils/dom\";\r\nimport { float, max } from \"../utils/number\";\r\nimport { objectIterator } from \"../utils/object\";\r\n\r\n\r\n/**\r\n * Creates Inputs component.\r\n *\r\n * @param {Element} container - Element to append the inputs container element to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} - Inputs component.\r\n */\r\nexport const Inputs = (container, alwan, events) => {\r\n\r\n    /**\r\n     * Inputs wrapper element.\r\n     */\r\n    let inputsContainer;\r\n\r\n    /**\r\n     * Switch button.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let switchButton;\r\n\r\n    /**\r\n     * Picker formats.\r\n     */\r\n    let formats = [];\r\n\r\n    /**\r\n     * Index of the current format.\r\n     */\r\n    let formatIndex;\r\n\r\n    /**\r\n     * Object that maps fields label to their inputs.\r\n     *\r\n     * @type {object}\r\n     */\r\n    let inputsMap;\r\n\r\n    /**\r\n     * Indicates that an input value has changed.\r\n     */\r\n    let isChanged = false;\r\n\r\n    /**\r\n     * Component API.\r\n     */\r\n    const self = {\r\n        /**\r\n         * Initialize Inputs.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ inputs, format }, instance) {\r\n\r\n            alwan = instance || alwan;\r\n            inputs = inputs || {};\r\n            inputsMap = {};\r\n\r\n            // Get only valid formats.\r\n            formats = COLOR_FORMATS.filter(format => inputs[format]);\r\n            let length = formats.length;\r\n\r\n            if (! length) {\r\n                // No inputs, remove inputs container and the switch button.\r\n                inputsContainer = removeElement(inputsContainer);\r\n                switchButton = removeElement(switchButton);\r\n\r\n                formats = COLOR_FORMATS;\r\n            } else {\r\n\r\n                // Create inputs container.\r\n                if (! inputsContainer) {\r\n                    inputsContainer = createElement('', INPUTS_CLASSNAME, container);\r\n                }\r\n\r\n                if (length > 1) {\r\n                    if (!switchButton) {\r\n                        // For more than one input format, add a switch button.\r\n                        switchButton = createButton('', container, { html: switchInputsSVG });\r\n                    }\r\n                } else {\r\n                    switchButton = removeElement(switchButton);\r\n                }\r\n            }\r\n\r\n            // Validate and normalize format value.\r\n            formatIndex = max(formats.indexOf(format), 0);\r\n            format = formats[formatIndex];\r\n            build(format);\r\n\r\n            // Show/Hide parent container.\r\n            toggleVisibility(container, length);\r\n        },\r\n\r\n        /**\r\n         * Updates Input(s) value(s).\r\n         *\r\n         * @param {Object} color - Color object.\r\n         */\r\n        _update(color) {\r\n            objectIterator(inputsMap, (input, key) => {\r\n                input.value = color[key];\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds inputs.\r\n     *\r\n     * @param {string} format - Color format.\r\n     */\r\n    const build = (format) => {\r\n\r\n        alwan._color._setFormat(format);\r\n\r\n        if (inputsContainer) {\r\n            let { singleInput, opacity } = alwan.config;\r\n            let fields;\r\n            let props;\r\n            // Each letter in the format variable represent a color channel,\r\n            // For multiple inputs, each color channel has an input field.\r\n            // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\r\n            if (singleInput || format === HEX_FORMAT) {\r\n                fields = [format];\r\n\r\n                props = {\r\n                    type: 'text',\r\n                }\r\n            } else {\r\n                fields = (format + (opacity ? 'a' : '')).split('');\r\n\r\n                props = {\r\n                    type: 'number',\r\n                    max: format === RGB_FORMAT ? 255 : 100,\r\n                    min: '0'\r\n                }\r\n            }\r\n\r\n            // Empty the container from any inputs.\r\n            setHTML(inputsContainer, '');\r\n\r\n            fields.forEach(field => {\r\n                /**\r\n                 * Create Input.\r\n                 *\r\n                 * <label>\r\n                 *     <input type=\"text|number\" class=\"alwan__input\">\r\n                 *     <span>${field}</span>\r\n                 * </label>\r\n                 */\r\n                const labelElement = createElement('label', '', inputsContainer);\r\n                inputsMap[field] = createElement(INPUT, INPUT_CLASSNAME, labelElement, props);\r\n                createElement('span', '', labelElement, { html: field });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles changes in inputs.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChange = ({ target: { value }}) => {\r\n\r\n        if (! isChanged) {\r\n            alwan._color._saveState();\r\n            isChanged = true;\r\n        }\r\n\r\n        let str = '';\r\n        let color = {};\r\n        let format = formats[formatIndex];\r\n\r\n        if (alwan.config.singleInput || format === HEX_FORMAT) {\r\n            str = value;\r\n        } else {\r\n            // Copy inputs values into an object (rgb or hsl).\r\n            objectIterator(inputsMap, (input, key) => {\r\n                color[key] = float(input.value);\r\n            });\r\n            // Convert the object into string.\r\n            str = stringify(color, format);\r\n        }\r\n\r\n        if (alwan._color._set(str, true)) {\r\n            alwan._events._dispatch(COLOR, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles when an input loses focus after its value was changed.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChangeStop = e => {\r\n        alwan._color._triggerChange(e.target);\r\n        isChanged = false;\r\n        alwan._color._update();\r\n    }\r\n\r\n    /**\r\n     * Changes color format.\r\n     *\r\n     * @param {MouseEvent} e - Click event.\r\n     */\r\n    const changeFormat = e => {\r\n        if (e.target === switchButton) {\r\n            // Increment input format index, reset it if it reaches the end.\r\n            // this index will point to the next format.\r\n            formatIndex = (formatIndex + 1) % formats.length;\r\n            build(formats[formatIndex]);\r\n            // Update values.\r\n            alwan._color._update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select input value when focus in, and close the picker when pressing Enter key.\r\n     *\r\n     * @param {FocusEvent|KeyboardEvent} e - Event.\r\n     */\r\n    const selectOrClose = ({ target, key, type }) => {\r\n        if (target !== switchButton) {\r\n            if (type === FOCUS_IN) {\r\n                target.select();\r\n            } else if (key === ENTER) {\r\n                alwan.close();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(container, CLICK, changeFormat);\r\n    events._bind(container, INPUT, handleChange);\r\n    events._bind(container, CHANGE, handleChangeStop);\r\n    events._bind(container, [KEY_DOWN, FOCUS_IN], selectOrClose);\r\n\r\n\r\n    return self;\r\n}","import { caretSVG } from \"../assets/svg\";\r\nimport { COLLAPSE_BUTTON_CLASSNAME, COLLAPSE_CLASSNAME, SWATCHES_CLASSNAME, SWATCH_CLASSNAME } from \"../constants/classnames\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { CHANGE, CLICK, COLOR, COLOR_PROPERTY } from \"../constants/globals\";\r\nimport { createButton, createElement, parent, removeElement, setCustomProperty, setHTML, toggleClassName } from \"../utils/dom\";\r\nimport { int } from \"../utils/number\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n/**\r\n * Creates swatches component.\r\n *\r\n * @param {Element} root - Element to append the palette element to.\r\n * @param {object} alwan - Picker Instance.\r\n * @param {object} events - Event binder.\r\n * @returns {object} - Swatches component.\r\n */\r\nexport const Swatches = (root, alwan, events) => {\r\n\r\n    /**\r\n     * Swatches container.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let container;\r\n\r\n    /**\r\n     * Swatches array.\r\n     *\r\n     * @type {array<string>}\r\n     */\r\n    let swatches;\r\n\r\n    /**\r\n     * Button.\r\n     *\r\n     * @type {HTMLButtonElement}\r\n     */\r\n    let collapseButton;\r\n\r\n    /**\r\n     * Swatches array length.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let swatchesLength;\r\n\r\n    /**\r\n     * Indicate whether swatches container is collapsible.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    let isCollapsible\r\n\r\n    /**\r\n     * Swatches API.\r\n     */\r\n    const self = {\r\n        /**\r\n         * Initialize swatches.\r\n         *\r\n         * @param {Object} options - Alwan options.\r\n         */\r\n        _init(options = {}, instance) {\r\n            alwan = instance || alwan;\r\n\r\n            swatches = options.swatches || swatches;\r\n            isCollapsible = options.toggleSwatches;\r\n            isCollapsible = isset(isCollapsible) ? isCollapsible : false;\r\n\r\n            if (Array.isArray(swatches)) {\r\n\r\n                swatchesLength = swatches.length;\r\n\r\n                if (swatchesLength) {\r\n                    // Create swatches container.\r\n                    if (! container) {\r\n                        container = createElement('', SWATCHES_CLASSNAME, root);\r\n                    } else {\r\n                        // Initialize container.\r\n                        setHTML(container, '');\r\n                    }\r\n\r\n                    // Create swatch button.\r\n                    swatches.forEach(color => {\r\n                        setCustomProperty(\r\n                            createButton(SWATCH_CLASSNAME, container),\r\n                            COLOR_PROPERTY,\r\n                            parseColor(color, true)\r\n                        );\r\n                    });\r\n\r\n                    // Create or remove the collapse button depend if the toggleSwatches,\r\n                    // option changes.\r\n                    if (isCollapsible) {\r\n                        if (! collapseButton) {\r\n                            collapseButton = createButton(COLLAPSE_BUTTON_CLASSNAME, root, { html: caretSVG });\r\n                        }\r\n                    } else {\r\n                        collapseButton = removeElement(collapseButton);\r\n                    }\r\n                    toggleClassName(container, COLLAPSE_CLASSNAME, isCollapsible);\r\n                } else {\r\n                    // Remove everything if the swatches array is empty.\r\n                    container = removeElement(container);\r\n                    collapseButton = removeElement(collapseButton);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Adds a swatch button.\r\n         *\r\n         * @param {String|object} color - Color.\r\n         */\r\n        _add(color) {\r\n            swatchesLength = swatches.push(color);\r\n            if (swatchesLength > 1) {\r\n                setCustomProperty(\r\n                    createButton(SWATCH_CLASSNAME, container),\r\n                    COLOR_PROPERTY,\r\n                    parseColor(color, true)\r\n                );\r\n            } else {\r\n                // Initialize component, if calling add swatches on an empty array.\r\n                self._init();\r\n            }\r\n        },\r\n        /**\r\n         * Removes a swatch button.\r\n         *\r\n         * @param {String|Number} swatch - Color or Swatch Index.\r\n         */\r\n        _remove(swatch) {\r\n            let index = swatches.findIndex((color, index) => swatch === color || int(swatch) === index);\r\n\r\n            if (index > -1) {\r\n                swatchesLength--;\r\n                // Remove swatch button.\r\n                removeElement(container.children[index]);\r\n                // Remove color from swatches array.\r\n                swatches.splice(index, 1);\r\n\r\n                if (! swatchesLength) {\r\n                    // Initialize component, if calling remove swatches on an array that,\r\n                    // has only one value.\r\n                    self._init();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Handles clicks in the swatches container or the collapse button.\r\n     *\r\n     * @param {MouseEvent} e - Event.\r\n     */\r\n    const handleClick = ({ target }) => {\r\n        if (target === collapseButton) {\r\n            toggleClassName(container, COLLAPSE_CLASSNAME);\r\n        }else if(parent(target) === container) {\r\n            alwan._color._set(target.style.getPropertyValue(COLOR_PROPERTY));\r\n            alwan._events._dispatch(COLOR, target);\r\n            alwan._events._dispatch(CHANGE, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(root, CLICK, handleClick);\r\n\r\n\r\n    return self;\r\n}","import { parseColor } from \"../colors/parser\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport { CHANGE, COLOR_PROPERTY, HEX_FORMAT, HSL_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { setCustomProperty } from \"../utils/dom\";\r\nimport { abs, max, min, normalizeAngle, round } from \"../utils/number.js\";\r\nimport { merge, objectIterator } from \"../utils/object\";\r\n\r\n/**\r\n * Creates the core color state and UI updater.\r\n *\r\n * @param {object} alwan - Alwan instance.\r\n * @returns {object} Core color state.\r\n */\r\nexport const color = (alwan) => {\r\n\r\n    /**\r\n     * RGB string used to update UI.\r\n     *\r\n     * @type {string}\r\n     */\r\n    let rgbString;\r\n\r\n    /**\r\n     * Save an rgb string.\r\n     *\r\n     * @type {string}\r\n     */\r\n    let savedColor;\r\n\r\n    /**\r\n     * Current color format.\r\n     *\r\n     * @type {'rgb'|'hsl'|'hex'}\r\n     */\r\n    let format;\r\n\r\n    /**\r\n     * Color state.\r\n     */\r\n    const state = {\r\n        // Hue.\r\n        h: 0,\r\n        // Saturation (capital S) and Lightness (capital L),\r\n        // are used internally, their values are between 0-1.\r\n        S: 0,\r\n        L: 0,\r\n\r\n        // HSL saturation and lightness (0-100)\r\n        s: 0,\r\n        l: 0,\r\n\r\n        // Red, Green and Blue values (0-255)\r\n        r: 0,\r\n        g: 0,\r\n        b: 0,\r\n\r\n        // Opacity value (0-1)\r\n        a: 1\r\n    }\r\n\r\n    /**\r\n     * Alwan options.\r\n     */\r\n    const config = alwan.config;\r\n\r\n    /**\r\n     * Updates the hsl values from a RGB object.\r\n     *\r\n     * @param {object} rgb - RGB color object.\r\n     */\r\n    const updateHSLFromRGB = (rgb) => {\r\n\r\n        let { r, g, b } = rgb;\r\n        let cMax, cMin, d, l, h;\r\n\r\n        r /= 255;\r\n        g /= 255;\r\n        b /= 255;\r\n\r\n        cMax = max(r, g, b);\r\n        cMin = min(r, g, b);\r\n        d = cMax - cMin;\r\n        l = (cMax + cMin) / 2;\r\n\r\n        h = d === 0 ?\r\n                    0\r\n                : cMax === r ? (g - b) / d % 6\r\n                : cMax === g ? (b - r) / d + 2\r\n                : cMax === b ? (r - g) / d + 4\r\n                : 0;\r\n\r\n        // Merge rgb object and the converted HSL into the state.\r\n        merge(state, rgb, {\r\n            h: normalizeAngle(h * 60),\r\n            S: d ? d / (1 - abs(2 * l - 1)) : 0,\r\n            L: l\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets color data.\r\n     *\r\n     * @param {object} color - Color object.\r\n     * @param {string} format - Color format.\r\n     * @param {boolean} asArray - Gets data as an array.\r\n     * @param {string} str - Color string.\r\n     * @returns {object} - Color data.\r\n     */\r\n    const colorData = (format, asArray, str) => {\r\n        return (format + (config.opacity ? 'a' : ''))\r\n                .split('')\r\n                .reduce((output, channel, index) => {\r\n                    output[asArray ? index : channel] = state[channel];\r\n                    return output;\r\n                }, merge(asArray ? [] : {}, { toString: () => str || stringify(state, format) }))\r\n    }\r\n\r\n    /**\r\n     * Helper function used for converting HSL to RGB.\r\n     *\r\n     * @param {number} k - Positive coefficient.\r\n     * @param {number} s - HSL saturation.\r\n     * @param {number} l - HSL lightness.\r\n     * @returns {number} - RGB component.\r\n     */\r\n    const fn = (k, s, l) => {\r\n        k %= 12;\r\n        return round((l - s * min(l, 1 - l) * max(-1, min(k - 3, 9 - k, 1))) * 255);\r\n    }\r\n\r\n\r\n    return {\r\n        /**\r\n         * Updates color state and the UI components.\r\n         *\r\n         * @param {object} hsl - HSL color object.\r\n         * @param {boolean} all - Whether to update the rest of the components (palette and sliders).\r\n         * @param {boolean} isInputs - If true don't update inputs.\r\n         * @param {boolean} isRGB - Color state changed from a RGB color.\r\n         */\r\n        _update(hsl, all, isInputs, isRGB) {\r\n            if (! config.disabled) {\r\n\r\n                merge(state, hsl);\r\n\r\n                let { h, S, L } = state;\r\n                let { _app: { _root }, _inputs, _palette, _sliders } = alwan._components;\r\n\r\n                if (! isRGB) {\r\n                    // Update rgb channels.\r\n                    h /= 30;\r\n                    state.r = fn(h, S, L);\r\n                    state.g = fn(h + 8, S, L);\r\n                    state.b = fn(h + 4, S, L);\r\n                }\r\n\r\n                state.s = round(S * 100);\r\n                state.l = round(L * 100);\r\n\r\n                rgbString = stringify(state, RGB_FORMAT);\r\n\r\n                // Update ui.\r\n                setCustomProperty(alwan._reference._element, COLOR_PROPERTY, rgbString);\r\n                setCustomProperty(_root, '--h', state.h);\r\n                setCustomProperty(_root, '--rgb', stringify(state, RGB_FORMAT, true));\r\n                setCustomProperty(_root, COLOR_PROPERTY, rgbString);\r\n\r\n                // Update Inputs.\r\n                if (! isInputs) {\r\n                    _inputs._update(config.singleInput || format === HEX_FORMAT ? { [format]: stringify(state, format) } : state);\r\n                }\r\n\r\n                // Update palette's marker position and sliders values.\r\n                if (all) {\r\n                    _palette._update(state);\r\n                    _sliders._update(state);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Saves the current state.\r\n         */\r\n        _saveState() {\r\n            savedColor = stringify(state, format);\r\n        },\r\n\r\n        /**\r\n         * Compares the current color state with the saved state. if they are different,\r\n         * then dipatch a change event.\r\n         *\r\n         * @param {Element} source - Event source.\r\n         */\r\n        _triggerChange(source) {\r\n            if (savedColor !== stringify(state, format)) {\r\n                alwan._events._dispatch(CHANGE, source);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets a new color.\r\n         *\r\n         * @param {string|object} color - Color string or object.\r\n         * @param {boolean} isInputs - If true, inputs values don't get updated.\r\n         */\r\n        _set(color, isInputs = false) {\r\n            let { _format, _color } = parseColor(color);\r\n            let isChanged = false;\r\n            let isRGB = _format === RGB_FORMAT;\r\n            let hsl;\r\n\r\n            // Compare parsed color channels (components) to the color state,\r\n            // channels.\r\n            objectIterator(_color, (value, channel) => {\r\n                if (value !== state[channel]) {\r\n                    isChanged = true;\r\n                }\r\n            });\r\n\r\n            if (isChanged) {\r\n                if (isRGB) {\r\n                    updateHSLFromRGB(_color);\r\n                } else {\r\n                    hsl = {\r\n                        h: _color.h,\r\n                        S: _color.s / 100,\r\n                        L: _color.l / 100,\r\n                        a: _color.a\r\n                    }\r\n                }\r\n\r\n                this._update(hsl, true, isInputs, isRGB);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets color value.\r\n         *\r\n         * @returns {object} - Color value.\r\n         */\r\n        _value() {\r\n            return {\r\n                value: rgbString,\r\n                rgb: asArray => colorData(RGB_FORMAT, asArray, rgbString),\r\n                hsl: asArray => colorData(HSL_FORMAT, asArray),\r\n                hex: () => stringify(state, HEX_FORMAT),\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets a new color format.\r\n         *\r\n         * @param {string} newFormat - Color format.\r\n         */\r\n        _setFormat(newFormat) {\r\n            format = config.format = newFormat;\r\n        }\r\n    }\r\n}","/**\r\n * SC Picker default options.\r\n */\r\n export const defaults = {\r\n    // Set the container's (widget) id.\r\n    id: '',\r\n\r\n    // One or many classes separated by a white space,\r\n    // to add it to the preset button.\r\n    classname: '',\r\n\r\n    // Choose a theme, 'dark' or 'light'.\r\n    theme: 'light',\r\n\r\n    // Toggle picker's visibility (Show/Hide),\r\n    // Setting this to false keeps the picker visible.\r\n    toggle: true,\r\n\r\n    // Display the picker container as a pop-up (a box that floats on top of the page content),\r\n    // if it's false, picker container will be displayed as a block (embeded in the page's content).\r\n    popover: true,\r\n\r\n    // Set the position of the popper (if popover is set to true) relative to the reference element,\r\n    // the position has two values seperated by a dash (-),\r\n    // the first value is the direction (top, bottom, right, left),\r\n    // the second value is the alignment (start, center, end), omitting this value will default to center.\r\n    // e.g. 'bottom-start': 'bottom' places the picker below the reference element,\r\n    // and 'start' aligns the left side of the container with the left side of the reference element.\r\n    // Note: \r\n    // If the picker container has no space to be placed, it will auto-position itself.\r\n    // based on the available space.\r\n    position: 'bottom-start',\r\n\r\n    // Set the gap (in pixels) between the picker container and the reference element.\r\n    margin: 8,\r\n\r\n    // Replace the reference element with a pre-styled button.\r\n    preset: true,\r\n\r\n    // Initial color.\r\n    color: '#000',\r\n\r\n    // Default color.\r\n    default: '#000',\r\n\r\n    // Target can be a selector or an HTML element,\r\n    // If the option popover is true, the picker container will be positionned retalive to this element,\r\n    // instead of the reference element.\r\n    // else if popover option is false, the picker container will be appended as a child into this element.\r\n    target: '',\r\n\r\n    // Disable the picker, users won't be able to pick colors.\r\n    disabled: false,\r\n\r\n    // Initial color format.\r\n    format: 'rgb',\r\n\r\n    // For the formats 'hsl' and 'rgb', choose a single input to display the color string,\r\n    // or if false, display an input for each color channel.\r\n    singleInput: false,\r\n\r\n    // Choose color formats for the picker input, 'hsl', 'rgb' or 'hex',\r\n    // No input will be displayed if the array is empty.\r\n    inputs: {\r\n        rgb: true,\r\n        hex: true,\r\n        hsl: true,\r\n    },\r\n\r\n    // Support alpha channel and display opacity slider.\r\n    opacity: true,\r\n\r\n    // Preview the color.\r\n    preview: true,\r\n\r\n    // Add/Remove a copy button.\r\n    copy: true,\r\n\r\n    // Array of color strings, invalid color strings will default to rgb(0,0,0).\r\n    swatches: [],\r\n\r\n    /**\r\n     * Share components with multiple alwan instances.\r\n     */\r\n    shared: false,\r\n\r\n    /**\r\n     * Make swatches container collapsible.\r\n     */\r\n    toggleSwatches: false,\r\n}","import { Reference } from \"./components/reference\";\r\nimport { merge, objectIterator, prototype, setPrototypeOf } from \"./utils/object\";\r\nimport { destroyComponents, isShared, useComponents } from \"./core/component\";\r\nimport { color } from \"./core/color\";\r\nimport { Dispatcher } from \"./core/events/dispatcher\";\r\nimport \"./assets/scss/alwan.scss\";\r\nimport { defaults } from \"./constants/defaults\";\r\nimport { isset } from \"./utils/util.js\";\r\n\r\n\r\nexport default class Alwan {\r\n\r\n    static version = VERSION;\r\n\r\n    /**\r\n     * Alwan defaults.\r\n     */\r\n    static defaults = defaults;\r\n\r\n    /**\r\n     * Alwan instance constructor.\r\n     *\r\n     * @param {String|Element} reference - The reference element.\r\n     * @param {Object} options - Options.\r\n     */\r\n    constructor(reference, options) {\r\n        let alwan = this;\r\n\r\n        alwan.config = merge({}, Alwan.defaults);\r\n        alwan._events = Dispatcher(alwan);\r\n        alwan._color = color(alwan);\r\n        alwan._reference = Reference(reference, alwan);\r\n        alwan.setOptions(options);\r\n    }\r\n\r\n    /**\r\n     * Sets new options.\r\n     *\r\n     * @param {Object} options - Alwan options.\r\n     */\r\n    setOptions(options) {\r\n        options = options || {};\r\n\r\n        let alwan = this;\r\n        let config = merge(alwan.config, options);\r\n        let { color, disabled } = options;\r\n        let core = alwan._color;\r\n        let app;\r\n\r\n        alwan._components = useComponents(alwan);\r\n        alwan._reference._init(config);\r\n        app = alwan._components._app;\r\n\r\n        if (isShared(alwan._components)) {\r\n            app._toggle(null, false);\r\n        }\r\n\r\n        app._setup(config, alwan);\r\n        alwan._reference._setDisabled(disabled);\r\n\r\n        if (isset(color)) {\r\n            core._set(color);\r\n        }\r\n\r\n        // To update inputs values.\r\n        core._update();\r\n    }\r\n\r\n    /**\r\n     * Gets the state of the picker whether it's opened or closed.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isOpen() {\r\n        return this._components._app._isOpen();\r\n    }\r\n\r\n    /**\r\n     * Opens the picker.\r\n     */\r\n    open() {\r\n        this._components._app._toggle(this, true);\r\n    }\r\n\r\n    /**\r\n     * Closes the picker.\r\n     */\r\n    close() {\r\n        this._components._app._toggle(this, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles (opens/closes) the picker.\r\n     */\r\n    toggle() {\r\n        this._components._app._toggle(this);\r\n    }\r\n\r\n    /**\r\n     * Attaches an event handler function for an event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    on(type, handler) {\r\n        this._events._addListener(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Detaches one or more event handlers.\r\n     *\r\n     * Note:\r\n     * omitting handler, remove all handlers from the event,\r\n     * omitting both event type and handler, remove all handlers that are,\r\n     * attached to all events.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    off(type, handler) {\r\n        this._events._removeListeners(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Sets a color.\r\n     *\r\n     * @param {String|Object} color - Color.\r\n     */\r\n    setColor(color) {\r\n        this._color._set(color);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets color.\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    getColor() {\r\n        return this._color._value();\r\n    }\r\n\r\n    /**\r\n     * Adds a swatch.\r\n     *\r\n     * @param {String} color - Color.\r\n     */\r\n    addSwatch(color) {\r\n        this._components._swatches._add(color);\r\n    }\r\n\r\n    /**\r\n     * Removes a swatch.\r\n     *\r\n     * @param {String|Number} swatch - Can a color string or it's index in the swatches array.\r\n     */\r\n    removeSwatch(swatch) {\r\n        this._components._swatches._remove(swatch);\r\n    }\r\n\r\n    /**\r\n     * Enables picker.\r\n     */\r\n    enable() {\r\n        this._reference._setDisabled(false);\r\n    }\r\n\r\n    /**\r\n     * Disables picker.\r\n     */\r\n    disable() {\r\n        this._reference._setDisabled(true);\r\n    }\r\n\r\n    /**\r\n     * Resets to default color.\r\n     */\r\n    reset() {\r\n        this._color._set(this.config.default);\r\n    }\r\n\r\n    /**\r\n     * Repositions picker if it's displayed as a popover.\r\n     */\r\n    reposition() {\r\n        this._components._app._reposition();\r\n    }\r\n\r\n    /**\r\n     * Executes all handlers attached to the specified event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     */\r\n    trigger(type) {\r\n        this._events._dispatch(type);\r\n    }\r\n\r\n    /**\r\n     * Destroy picker and free up memory.\r\n     */\r\n    destroy() {\r\n        let alwan = this;\r\n\r\n        alwan._reference._destroy();\r\n        destroyComponents(alwan._components);\r\n\r\n        // Remove all properties of this instance.\r\n        objectIterator(alwan, (_, key) => {\r\n            delete alwan[key];\r\n        });\r\n\r\n        // Empty instance prototype.\r\n        setPrototypeOf(alwan, prototype);\r\n    }\r\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants/globals\"\r\nimport { merge, objectIterator } from \"../../utils/object\";\r\nimport { isset } from \"../../utils/util\";\r\n\r\n/**\r\n * Alwan events.\r\n *\r\n * @param {Alwan} alwan - Alwan Instance.\r\n * @returns \r\n */\r\nexport const Dispatcher = (alwan) => {\r\n    /**\r\n     * Alwan event listeners.\r\n     */\r\n    const listeners = {\r\n        [OPEN]: [],\r\n        [CLOSE]: [],\r\n        [CHANGE]: [],\r\n        [COLOR]: []\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Dispatch an event.\r\n         *\r\n         * @param {string} type - Event type.\r\n         * @param {object} ev - Event object.\r\n         */\r\n        _dispatch(type, source) {\r\n            if (! alwan.config.disabled) {\r\n                (listeners[type] || []).forEach(handler => {\r\n                    handler(merge({ type, source }, alwan._color._value()));\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Add an event listener.\r\n         *\r\n         * @param {string} eventType - Event type.\r\n         * @param {CallableFunction} eventHandler - Event handler to registered.\r\n         */\r\n        _addListener(eventType, eventHandler) {\r\n            if (listeners[eventType] && ! listeners[eventType].includes(eventHandler)) {\r\n                listeners[eventType].push(eventHandler);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove event listener(s).\r\n         *\r\n         * @param {string} type - Event type.\r\n         * @param {CallableFunction} handlerToRemove - Event handler to remove.\r\n         */\r\n        _removeListeners(eventType, handlerToRemove) {\r\n\r\n            let handlers = eventType && listeners[eventType];\r\n\r\n            if (isset(eventType)) {\r\n                if (handlers) {\r\n                    if (isset(handlerToRemove)) {\r\n                        listeners[eventType] = handlers.filter((handler => handler !== handlerToRemove));\r\n                    } else {\r\n                        listeners[eventType] = [];\r\n                    }\r\n                }\r\n            } else {\r\n                objectIterator(listeners, (_array, eventType) => {\r\n                    listeners[eventType] = [];\r\n                });\r\n            }\r\n        }\r\n    }\r\n}","import { PRESET_BUTTON_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLICK } from \"../constants/globals\";\r\nimport { Binder } from \"../core/events/binder\";\r\nimport { body, createButton, getElement, removeElement, replaceElement, toggleClassName } from \"../utils/dom\";\r\nimport { isString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n/**\r\n * Creates the reference control.\r\n *\r\n * @param {string|Element} reference - User Reference.\r\n * @param {Alwan} param1 - Alwan instance.\r\n * @returns {object} - ReferenceElement control.\r\n */\r\nexport const Reference = (reference, alwan) => {\r\n\r\n    /**\r\n     * Reference element classes.\r\n     */\r\n    let classes = [];\r\n\r\n    /**\r\n     * Event binder.\r\n     */\r\n    const events = Binder();\r\n\r\n    /**\r\n     * Body.\r\n     */\r\n    const bodyElement = body();\r\n\r\n    /**\r\n     * Reference element.\r\n     *\r\n     * @type {Element|null}\r\n     */\r\n    const element = getElement(reference);\r\n\r\n    /**\r\n     * User reference.\r\n     *\r\n     * Check if the reference element is valid.\r\n     */\r\n    const userReference = bodyElement.contains(element) && element !== bodyElement ? element : null;\r\n\r\n    /**\r\n     * Reference API.\r\n     */\r\n    const self = {\r\n        // If user reference is not valid element in the body, then create,\r\n        // a preset button and append it to the body.\r\n        _element: userReference ? userReference : createButton(PRESET_BUTTON_CLASSNAME, bodyElement),\r\n\r\n        /**\r\n         * Initialize Reference element.\r\n         *\r\n         * @param {object} param - Alwan options.\r\n         */\r\n        _init({ preset, classname }) {\r\n            let element = self._element;\r\n\r\n            // If the user reference is valid then replace it with the preset button,\r\n            // if preset option is true.\r\n            if (userReference && preset !== (userReference !== element)) {\r\n                // Clear events, element might be deleted.\r\n                events._unbindAll();\r\n\r\n                if (preset) {\r\n                    // Replace user reference with a preset button.\r\n                    element = replaceElement(createButton(PRESET_BUTTON_CLASSNAME, null, { id: userReference.id }), userReference);\r\n                } else {\r\n                    // Replace preset button with the user reference.\r\n                    element = replaceElement(userReference, element);\r\n                }\r\n\r\n                /**\r\n                 * Handles click.\r\n                 */\r\n                events._bind(element, CLICK, e => {\r\n                    alwan._components._app._toggle(alwan);\r\n                });\r\n            }\r\n\r\n            // Add custom classes to the preset button.\r\n            if (! userReference || preset && isString(classname)) {\r\n                // Remove previously add classes.\r\n                toggleClassName(element, classes, false);\r\n                classes = classname.split(/\\s+/);\r\n                // Add the new classname.\r\n                toggleClassName(element, classes, true);\r\n            }\r\n\r\n            self._element = element;\r\n        },\r\n\r\n        /**\r\n         * Disables/Enables Picker instance.\r\n         *\r\n         * @param {boolean} disabled - Disable/Enable.\r\n         */\r\n        _setDisabled(disabled) {\r\n            if (isset(disabled)) {\r\n                let { config, _components } = alwan;\r\n                let { shared, toggle } = config;\r\n                let toggler = _components._app._toggle;\r\n\r\n                config.disabled = self._element.disabled = !! disabled;\r\n\r\n                if (disabled) {\r\n                    toggler(alwan, false, true);\r\n                } else if (! shared && ! toggle) {\r\n                    toggler(alwan, true, true);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Destroy reference component.\r\n         */\r\n        _destroy() {\r\n            if (userReference) {\r\n                self._init({ preset: false });\r\n            } else {\r\n                self._element = removeElement(self._element);\r\n            }\r\n            events._unbindAll();\r\n        }\r\n    }\r\n\r\n    return self;\r\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ALWAN_CLASSNAME","CONTAINER_CLASSNAME","PALETTE_CLASSNAME","MARKER_CLASSNAME","PREVIEW_CLASSNAME","BUTTON_CLASSNAME","COPY_BUTTON_CLASSNAME","SLIDER_CLASSNAME","SLIDERS_CLASSNAME","HUE_SLIDER_CLASSNAME","ALPHA_SLIDER_CLASSNAME","INPUT_CLASSNAME","INPUTS_CLASSNAME","SWATCH_CLASSNAME","SWATCHES_CLASSNAME","PRESET_BUTTON_CLASSNAME","OVERLAY_CLASSNAME","COLLAPSE_BUTTON_CLASSNAME","POPUP_CLASSNAME","OPEN_CLASSNAME","COLLAPSE_CLASSNAME","ROOT","document","HTML","documentElement","BUTTON","OPEN","CLOSE","COLOR","CLICK","POINTER_DOWN","KEY_DOWN","INPUT","CHANGE","FOCUS_IN","HEX_FORMAT","RGB_FORMAT","HSL_FORMAT","COLOR_PROPERTY","COLOR_FORMATS","INSERT_BEFORE_FIRST_CHILD","isString","value","trimString","str","trim","Binder","eventListenersData","toggleEventListener","eventTarget","events","handler","toggler","forEach","event","_bind","push","_unbindAll","target","keys","assign","merge","setPrototypeOf","objectIterator","object","fn","props","isset","body","getElement","reference","context","all","Element","insertElement","element","targetElement","where","insertAdjacentElement","setHTML","html","innerHTML","createElement","tagName","className","details","insertPosition","name","setAttribute","getBounds","x","y","top","left","right","clientWidth","bottom","clientHeight","getBoundingClientRect","parent","parentElement","replaceElement","newElement","oldElement","replaceChild","removeElement","remove","getScrollableAncestors","scrollables","test","getComputedStyle","overflow","setCustomProperty","property","style","setProperty","toggleVisibility","display","toggleClassName","tokens","token","classList","toggle","createButton","type","translate","transform","createSlider","max","step","parseFloat","float","parseInt","int","isFinite","isNumeric","Number","min","abs","round","PI","Math","boundNumber","number","upperBound","lowerBound","normalizeAngle","angle","TOP","BOTTOM","RIGHT","LEFT","START","CENTER","END","dimension","App","alwan","referenceElement","popper","scrollableAncestors","popperEvents","isOpen","_setup","options","instance","theme","popover","position","margin","id","shared","_components","_init","_reference","_element","dataset","_toggle","container","_margin","_position","coordinates","fallbackSides","fallbackAlignments","start","center","end","side","alignment","split","_update","domBounds","referenceBoundingRect","containerBoundingRect","some","referenceSide","axis","domBound","referenceBound","containerSpace","containerDimension","referenceLowerBound","referenceUpperBound","upperBoundDistance","offset","createPopper","window","updatePopper","scrollable","handleAccessibility","e","every","elementX","elementY","elementBottom","elementRight","scrollableX","scrollableY","scrollableBottom","scrollableRight","elementToFocusOn","lastFocusableElement","shiftKey","paletteElement","_palette","contains","labels","label","pop","preventDefault","focus","state","forced","disabled","config","_color","_reposition","_events","_dispatch","_root","_isOpen","_destroy","clipboardSVG","toHex","toString","stringify","color","format","opaque","opacity","a","r","g","b","h","s","l","ctx","getContext","HSL_REGEX","HEX_REGEX","ANGLE_COEFFICIENT_MAP","deg","turn","rad","grad","parseColor","asString","find","input","percentage","exec","fillStyle","slice","map","_format","sharedComponents","instanceCount","createComponents","createContainer","_app","markerX","markerY","paletteBounds","overlayElement","isPointerDown","palette","tabindex","marker","keyboardX","ArrowRight","ArrowLeft","keyboardY","ArrowDown","ArrowUp","moveMarkerAndUpdateColor","clientX","clientY","keyboard","change","v","L","width","height","S","_saveState","_triggerChange","_options","Palette","_utility","previewElement","copyButton","isCopied","preview","copy","clipboard","navigator","_getColorByFormat","writeText","select","execCommand","blur","Utility","_sliders","alphaSlider","hueSlider","Sliders","_inputs","inputsContainer","switchButton","formatIndex","inputsMap","formats","isChanged","inputs","filter","length","indexOf","build","_setFormat","fields","singleInput","field","labelElement","_set","close","Inputs","_swatches","swatches","collapseButton","swatchesLength","isCollapsible","toggleSwatches","Array","isArray","_add","_remove","swatch","index","findIndex","children","splice","getPropertyValue","Swatches","isShared","components","destroyComponents","rgbString","savedColor","colorData","asArray","reduce","output","channel","k","hsl","isInputs","isRGB","source","rgb","cMax","cMin","d","updateHSLFromRGB","this","_value","hex","newFormat","defaults","classname","preset","default","Alwan","VERSION","constructor","listeners","_addListener","eventType","eventHandler","includes","_removeListeners","handlerToRemove","handlers","_array","Dispatcher","classes","bodyElement","userReference","_setDisabled","Reference","setOptions","app","core","useComponents","open","on","off","setColor","getColor","addSwatch","removeSwatch","enable","disable","reset","reposition","trigger","destroy","_"],"sourceRoot":""}